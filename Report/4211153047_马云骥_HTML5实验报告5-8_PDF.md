<!-- 请使用 Typora + LaTeX-theme 来预览、编辑和导出PDF
Typora: https://typora.io/
LaTeX-theme: https://github.com/Keldos-Li/typora-latex-theme
Fonts: https://github.com/Keldos-Li/typora-latex-theme-fonts -->

<div class="cover" style="page-break-after:always;font-family:方正公文仿宋;width:100%;height:100%;border:none;margin: 0 auto;text-align:center;">
    <div style="width:60%;margin: 0 auto;height:0;padding-bottom:10%;">
        </br></br></br></br></br></br>
        <img src="https://raw.githubusercontent.com/SlenderData/img/main/images/%E5%B8%B8%E7%94%A8/%E5%AD%A6%E6%A0%A1%E6%A0%87%E8%AF%86/%E6%B1%9F%E8%8B%8F%E5%A4%A7%E5%AD%A6%E4%BA%AC%E6%B1%9F%E5%AD%A6%E9%99%A2/%E6%96%87%E5%AD%97%E7%BB%84%E5%90%88%E6%A8%AA%E6%8E%92.svg" alt="校名" style="width:100%;"/>
    </div>
    </br></br></br></br></br></br></br></br></br></br>
    <div style="width:40%;margin: 0 auto;height:0;padding-bottom:40%;">
        <img src="https://raw.githubusercontent.com/SlenderData/img/main/images/%E5%B8%B8%E7%94%A8/%E5%AD%A6%E6%A0%A1%E6%A0%87%E8%AF%86/%E6%B1%9F%E8%8B%8F%E5%A4%A7%E5%AD%A6%E4%BA%AC%E6%B1%9F%E5%AD%A6%E9%99%A2/%E6%A0%A1%E5%BE%BD.svg" alt="校徽" style="width:100%;"/>
	</div>
    </br></br></br>
    <span style="font-family:华文黑体Bold;text-align:center;font-size:30pt;margin: 10pt auto;line-height:40pt;">HTML5 编程<br>实验报告</span>
    </br>
    </br>
    </br>
    </br>
    <table style="border:none;text-align:center;width:72%;font-family:仿宋;font-size:14px; margin: 0 auto;">
    <tbody style="font-family:方正公文仿宋;font-size:12pt;">
    	<tr style="font-weight:normal;"> 
    		<td style="width:5%;text-align:right;">题&emsp;&emsp;目</td>
    		<td style="width:2%">：</td> 
    		<td style="width:40%;font-weight:normal;border-bottom: 1px solid;text-align:center;font-family:华文仿宋">HTML5 实验报告 5-8</td>     </tr>
    	<tr style="font-weight:normal;"> 
    		<td style="width:5%;text-align:right;">授课教师</td>
    		<td style="width:2%">：</td> 
    		<td style="width:40%;font-weight:normal;border-bottom: 1px solid;text-align:center;font-family:华文仿宋">王良君</td>     </tr>
    	<tr style="font-weight:normal;"> 
    		<td style="width:5%;text-align:right;">姓&emsp;&emsp;名</td>
    		<td style="width:2%">：</td> 
    		<td style="width:40%;font-weight:normal;border-bottom: 1px solid;text-align:center;font-family:华文仿宋">马云骥</td>     </tr>
    	<tr style="font-weight:normal;"> 
    		<td style="width:5%;text-align:right;">学&emsp;&emsp;号</td>
    		<td style="width:2%">：</td> 
    		<td style="width:40%;font-weight:normal;border-bottom: 1px solid;text-align:center;font-family:华文仿宋">4211153047</td>     </tr>
        <tr style="font-weight:normal;"> 
    		<td style="width:5%;text-align:right;">专&emsp;&emsp;业</td>
    		<td style="width:2%">：</td> 
    		<td style="width:40%;font-weight:normal;border-bottom: 1px solid;text-align:center;font-family:华文仿宋">软件工程</td>     </tr>
    	<tr style="font-weight:normal;"> 
    		<td style="width:5%;text-align:right;">班&emsp;&emsp;级</td>
    		<td style="width:2%">：</td> 
    		<td style="width:40%;font-weight:normal;border-bottom: 1px solid;text-align:center;font-family:华文仿宋">J软件(嵌入)(专转本)2102</td>     </tr>
    	<tr style="font-weight:normal;"> 
    		<td style="width:5%;text-align:right;">日&emsp;&emsp;期</td>
    		<td style="width:2%">：</td> 
    		<td style="width:40%;font-weight:normal;border-bottom: 1px solid;text-align:center;font-family:华文仿宋">2024.05.12</td>     </tr>
    </tbody>              
    </table>
</div>

<!-- 导出PDF时会在这里分页 -->

# HTML5 实验报告 5-8

## 实验五：饼状图和柱状图绘制

### 实验目的

1. 熟悉使用canvas绘制图形
2. 熟悉表单组件及按钮相应事件

### 实验要求

&emsp;&emsp;在网页中添加表单组件，要求用户输入统计数据，根据用户数据绘制相应的饼状图和柱状图。

1. 要求对用户输入进行有效性验证；
2. 通过点击按钮绘制饼状图或柱状图；
3. 饼状图和柱状图要有数据标注。

### 实验设计

&emsp;&emsp;完整代码篇幅过长，详见后面的代码附件或我的 GitHub 仓库：[HTML5-Learning/Experiment-5/CanvasChart.html at main · SlenderData/HTML5-Learning (github.com)](https://github.com/SlenderData/HTML5-Learning/blob/main/Experiment-5/CanvasChart.html)

&emsp;&emsp;我创建了一个网页应用，允许用户通过表单输入数据并根据这些数据绘制饼状图和柱状图。以下是代码的主要功能和组件的详细分析：

#### HTML 结构

- 页面被分为两大部分：输入区(`inputArea`)和绘图区(`drawArea`)。
- **输入区**包含一个表单，用户可以输入图表标题和多组数据（类目名和数据值）。数据输入表使用可编辑的`<td>`元素来收集用户输入。
- **绘图区**包含一个`<canvas>`元素，用于显示生成的图形。

#### CSS 样式

- 页面采用了简洁的设计风格，使用网格布局(`grid`)来安排输入区和绘图区。
- 使用了圆角(`border-radius`)、阴影(`box-shadow`)和渐变背景(`background-color`)等样式属性增强视觉效果。
- 输入表格和按钮均有明确的样式定义，以提升用户交互体验。

#### JavaScript 功能

- **数据生成与验证**：
  - `generateRandomData()`函数允许用户生成随机的测试数据，方便快速测试图形的绘制。
  - `getTableData()`函数从表格中收集数据，进行有效性验证（如检查空值和数字格式），并计算每个数据的百分比。

- **图形绘制**：
  - `drawPieChart()`和`drawBarChart()`函数分别用于绘制饼状图和柱状图。
  - 这些函数首先调用`getTableData()`获取和验证数据，然后使用Canvas API进行图形绘制。如果数据验证失败，则提前退出并提示用户。
  - 图形的颜色是通过`chooseColor()`函数动态选择的，确保图形多样性和视觉美感。

- **Canvas 适配**：使用设备像素比(`devicePixelRatio`)来适配不同分辨率的屏幕，确保图形在高分辨率设备上的显示清晰。

&emsp;&emsp;总体而言，这个实验有效地结合了前端技术的多个方面，不仅涵盖了数据处理和验证，也包括了图形的动态绘制，是一个综合性的编程实践活动。

### 实验结果

👉 **[在线预览](https://slenderdata.github.io/HTML5-Learning/Experiment-5/CanvasChart.html)**

![截屏2024-05-12-21.02.54](https://raw.githubusercontent.com/SlenderData/img/main/images/2024/05/12/21-30-20-4be79de434bc7cfabe1db4d79451ce05-截屏2024-05-12-21.02.54-b1d425.png)

![截屏2024-05-12-21.03.01](https://raw.githubusercontent.com/SlenderData/img/main/images/2024/05/12/21-30-37-83bd852fc966d5c49a8e654a0f0785de-截屏2024-05-12-21.03.01-d2de01.png)

### 实验总结

&emsp;&emsp;在这次实验中，我设计并实现了一个可以根据用户输入数据绘制饼状图和柱状图的网页应用。通过这个过程，我深入理解了如何使用Canvas API来绘制图形，并熟悉了表单组件的使用及其与按钮事件的互动。这次实验让我掌握了前端开发中的关键技术，同时也加深了对数据可视化的理解。

&emsp;&emsp;首先，实验的核心在于处理用户输入的数据并将其转换为图形。这包括了从表单获取数据、数据验证以及数据的适当处理，如计算百分比等。这一部分挑战了我的数据处理技能，尤其是在进行数据有效性验证和错误处理方面。

&emsp;&emsp;其次，绘图部分让我深入使用了Canvas API，包括如何绘制路径、设置颜色、填充图形以及添加文本。通过实现两种不同类型的图表（饼状图和柱状图），我了解到了每种图表的绘制方法和技术要点。这不仅增强了我的编程技能，还提高了我解决图形相关问题的能力。

&emsp;&emsp;此外，我还学习了如何通过JavaScript动态操作DOM，实现了用户交互功能，如按钮点击事件处理和表单动态更新。这些功能的实现提升了应用的用户体验，使得用户可以实时地看到数据变更和图表更新的效果。

&emsp;&emsp;总结来说，这次实验是一个综合性的编程挑战，涵盖了从前端设计到后端逻辑的多个方面。通过这次实验，我不仅提升了自己在数据处理、图形绘制和用户界面设计方面的技能，还更加了解了如何将复杂的用户需求转化为实际的应用功能。这对我的编程职业生涯是一个宝贵的学习经历。

<div style="page-break-after:always;"></div>

## 实验六：视频播放器设计

### 实验目的

1. 熟悉使用媒体API
2. 熟悉按钮响应事件

### 实验要求

&emsp;&emsp;在网页中设计一款视频播放器，要求不使用自带控制面板，通过自定义按钮，实现以下功能：

1. 播放、暂停、静音等功能；
2. 视频放大和缩小；
3. 播放上一个和下一个文件；
4. 快进和快退功能。

&emsp;&emsp;其他功能可自行设计，界面尽量做到美观大方，可插入背景图片。

### 实验设计

&emsp;&emsp;完整代码篇幅过长，详见后面的代码附件或我的 GitHub 仓库：[HTML5-Learning/Experiment-6/VideoPlayer.html at main · SlenderData/HTML5-Learning (github.com)](https://github.com/SlenderData/HTML5-Learning/blob/main/Experiment-6/VideoPlayer.html)

&emsp;&emsp;实验六的代码中，我设计了一个网页视频播放器，其中采用了HTML5的`<video>`标签并自定义了播放控制按钮，以满足实验的要求。以下是对实验代码的详细分析：

#### HTML结构

- 页面包括两个主要区域：一个信息展示区(`infoArea`)和一个播放器区域(`playerArea`)。
- **信息展示区**展示了即将播放的视频列表以及当前播放的专辑封面、音乐名称、专辑名称和艺术家信息。
- **播放器区域**包含了视频播放的`<video>`元素以及一系列控制按钮，如播放/暂停、前进/后退、音量控制等。

#### CSS样式

- 页面采用了`grid`布局，将信息区和播放器区并排显示，提高了布局的灵活性和页面的整体美观。
- 视频和信息区域通过背景色、圆角和阴影的应用，实现了简洁且现代的界面设计。
- 按钮和其他控件采用一致的设计风格，增强了用户界面的一致性。

#### JavaScript 功能

- **视频播放控制**：实现了基本的播放器操作如播放/暂停、快进/快退、音量控制等。这些功能通过JavaScript直接操作`<video>`元素的属性和方法来实现。
- **视频切换功能**：通过前后按钮可以切换播放列表中的视频。列表中的每个视频都可以单击直接播放。
- **播放列表管理**：视频数据保存在一个数组中，并可以通过按钮随机化顺序或者根据用户选择调整当前播放视频。
- **界面响应**：对视频播放状态的改变（如播放、暂停、音量变化）进行监听，并相应地更新控制按钮的显示，增强了用户的交互体验。

&emsp;&emsp;总结来说，这个实验不仅使我能够掌握如何使用HTML5的视频播放和控制技术，还让我通过设计一系列交互按钮来实现复杂的用户界面交互，是一个非常实用且有教育意义的项目。

### 实验结果

👉 **[在线预览](https://slenderdata.github.io/HTML5-Learning/Experiment-6/VideoPlayer.html)**

![截屏2024-05-12-21.08.07](https://raw.githubusercontent.com/SlenderData/img/main/images/2024/05/12/21-32-01-e9569cdf3c25824ebfc773460b7b6fb4-截屏2024-05-12-21.08.07-afa715.png)

### 实验总结

&emsp;&emsp;在这次实验中，我设计并实现了一个自定义的网页视频播放器，深入探索了HTML5的媒体API及其在视频播放控制上的应用。通过这个过程，我不仅学习了如何控制媒体元素，还熟悉了事件驱动编程和用户界面设计，使我能够更好地理解和运用现代Web技术来创建富有交互性的应用。

&emsp;&emsp;首先，实验的核心在于处理视频播放的控制逻辑。我通过编写JavaScript函数来控制视频的播放、暂停、快进、快退以及音量控制等功能。这些功能的实现依赖于对`<video>`标签API的深入了解和应用，例如如何通过`play()`和`pause()`方法控制播放状态，以及如何通过修改`currentTime`属性来实现快进和快退功能。

&emsp;&emsp;其次，我设计的播放器不使用浏览器自带的控制面板，而是创建了一组自定义按钮来控制视频。这不仅提高了播放器的灵活性，也增强了用户的交互体验。每个按钮的功能都通过监听点击事件来实现，这部分工作加深了我对DOM事件处理的理解。

&emsp;&emsp;此外，我还在播放器中实现了播放列表的功能，用户可以选择播放列表中的任何一个视频文件进行播放。通过动态更新播放列表和当前播放视频的信息（如封面、标题、艺术家等），使得播放器的功能更加完整和用户友好。

&emsp;&emsp;总结来说，这次实验不仅提升了我的技术能力，也让我对如何设计和实现用户友好的界面有了更深的理解。通过实际操作，我学到了许多关于前端开发的实用技巧，这些都是在书本上难以获得的经验。未来，我期待将这些知识应用到更广泛的项目中，创建更加动态和互动的Web应用。

<div style="page-break-after:always;"></div>

## 实验七：响应式放大悬浮菜单

### 实验目的

1. 熟悉 CSS3 transition 动画过程
2. 熟悉 CSS3 阴影效果的使用

### 实验要求

&emsp;&emsp;利用 CSS3 动画技术制作响应式放大悬浮菜单，具体要求：

1. 在网页中添加多个菜单，菜单文字内容自定；
2. 在用户鼠标悬浮于菜单上方后，菜单动画放大；
3. 放大后的菜单添加阴影使其悬浮于页面之上，具有立体感。

### 实验设计

&emsp;&emsp;完整代码篇幅过长，详见后面的代码附件或我的 GitHub 仓库：[HTML5-Learning/Experiment-7/CSS3Menu.html at main · SlenderData/HTML5-Learning (github.com)](https://github.com/SlenderData/HTML5-Learning/blob/main/Experiment-7/CSS3Menu.html)

&emsp;&emsp;实验七的代码中我设计了一个响应式放大悬浮菜单，通过使用CSS3动画和阴影效果，使得菜单在用户鼠标悬浮时动态地放大并显示出悬浮效果。

#### HTML 结构

- 页面主要由两个部分组成：`info` 和 `tracks`，分别用于显示封面图、标题和歌曲列表。
- 歌曲列表以`<ul>`和`<li>`标签实现，每个`<li>`项即为一个菜单项。

#### CSS 样式

- 使用了CSS3的`transition`属性，实现了`<li>`元素在悬浮时的平滑放大和背景、阴影的变化效果。
- 对于`<li>`的放大效果，通过调整`font-size`、`line-height`、`width`和`height`等属性，并适当地修改`background-color`和`box-shadow`属性，增强了视觉上的悬浮效果。
- 阴影效果(`box-shadow`)在正常状态下为无，悬浮时变为明显的阴影，使元素看起来像是从页面上浮起来。
- 为整个页面设置了统一的背景和字体风格，增强了视觉的协调性。

#### 动画效果

- `transition: 0.5s;` 确保了元素变化的动画流畅和自然。所有属性变化都在0.5秒内平滑过渡，包括大小、颜色和阴影。
- 放大效果主要通过改变`<li>`的尺寸和字体大小实现，同时伴随背景色和阴影的变化，给用户以直观的反馈。

&emsp;&emsp;总结来说，这个实验不仅让我深入了解了CSS3的动画和阴影技术，还通过实际操作提升了处理响应式视觉效果的能力。通过这样的实验设置，可以有效地提高前端设计和编程的技能，尤其是在创建动态和吸引人的用户界面方面。

### 实验结果

👉 **[在线预览](https://slenderdata.github.io/HTML5-Learning/Experiment-7/CSS3Menu.html)**

![截屏2024-05-12-21.09.17](https://raw.githubusercontent.com/SlenderData/img/main/images/2024/05/12/21-32-24-65de7a1eb64dff4506ea7621f13afd61-截屏2024-05-12-21.09.17-67cc0b.png)

![截屏2024-05-12-21.10.36](https://raw.githubusercontent.com/SlenderData/img/main/images/2024/05/12/21-32-36-dae2d957f541940c29e0ba2433498a81-截屏2024-05-12-21.10.36-6334c9.png)

### 实验总结

&emsp;&emsp;在这次实验中，我设计并实现了一个响应式放大悬浮菜单，通过应用CSS3的动画和阴影效果，使得菜单项在用户悬浮时动态放大并显示出明显的悬浮效果。这个过程不仅加深了我对CSS3动画和视觉效果的应用理解，也提升了我在创建交互式Web界面方面的技能。

&emsp;&emsp;首先，实验的核心在于通过CSS3的`transition`和`box-shadow`属性来实现动画和视觉效果。我为每个菜单项配置了`transition`属性，使其在用户悬浮时能够平滑地放大并改变背景色和阴影。这种平滑的视觉过渡不仅增强了用户体验，也使界面看起来更加现代和吸引人。

&emsp;&emsp;其次，我特别注意了阴影效果的应用，这是实验中的一个重要部分。在菜单项悬浮时，我通过增加阴影的模糊半径和扩散范围，创建了一种元素浮起的立体感。这种效果不仅提升了元素的视觉层次，还加强了用户的交互感。

&emsp;&emsp;总结来说，这次实验是一个极好的学习经历，它不仅让我熟悉了CSS3的先进特性，还提高了我在实际项目中处理用户界面动态效果的能力。通过这样的实践，我能够更好地理解如何将复杂的设计转化为代码，以及如何利用CSS技术来提升网页的美观性和功能性。未来，我期待在更多项目中应用这些技能，继续探索和创新更多的交互设计可能。

<div style="page-break-after:always;"></div>

## 实验八：贪吃蛇小游戏设计与实现

### 实验目的

1. JavaScript编程综合能力训练。
2. 熟悉Canvas的使用。
3. 熟悉DOM事件。

### 实验要求

&emsp;&emsp;使用JavaScript设计一款贪吃蛇小游戏，要求如下：

1. 玩家可通过上下左右按键控制蛇头的移动方向使其向指定方向移动，并吃掉随机位置上的食物来获得分数。
2. 每吃掉一个食物，蛇身都会边长，并且在随机位置上出现下一个食物。
3. 如果蛇头碰到自身或墙壁，则游戏结束。
4. 游戏还可根据游戏的难度设置不同的游戏速度。

### 实验设计

&emsp;&emsp;完整代码篇幅过长，详见后面的代码附件或我的 GitHub 仓库：[HTML5-Learning/Experiment-8/GluttonousSnake.html at main · SlenderData/HTML5-Learning (github.com)](https://github.com/SlenderData/HTML5-Learning/blob/main/Experiment-8/GluttonousSnake.html)

&emsp;&emsp;在实验八中，我设计并实现了一个贪吃蛇小游戏，这是一个通过JavaScript和HTML5 Canvas技术实现的动态交互游戏。实验的重点在于使用Canvas进行图形绘制、处理键盘事件以控制游戏对象，以及通过DOM操作更新游戏状态。此外，实验还涵盖了使用JavaScript来处理游戏逻辑、动态生成内容和控制动画的技巧。以下是详细的实现说明：

#### 游戏画布的设置

&emsp;&emsp;首先，通过HTML和CSS创建一个网格状的游戏区域。这个区域包含了一个大的`table`元素，其内部生成相应数量的子`td`元素作为游戏的单元格，然后根据需要动态地在`td`元素内插入删除`canvas`元素来实现。单元格的大小和间隔可以通过用户输入控制，从而改变游戏的视觉效果。

#### 蛇的表示和逻辑处理

&emsp;&emsp;蛇通过一个双向链表来表示，链表的每个节点代表蛇身上的一段。链表头部代表蛇头，尾部代表蛇尾。每次移动时，根据蛇头的方向，在头部添加一个新节点，并从尾部移除一个节点，实现蛇的前进。如果蛇头移动到的位置有食物，则只添加新节点不移除，实现蛇的增长。

#### 控制与输入

&emsp;&emsp;使用JavaScript监听键盘事件，允许玩家通过方向键或WASD键控制蛇的移动方向。在逻辑中检查这些输入，确保蛇不会向自身直接相反的方向移动。

#### 食物的生成

&emsp;&emsp;每当蛇吃掉一个食物后，随机在游戏区域内未被蛇身占用的单元格生成新的食物。这一步涉及到随机数的生成和对游戏区域的扫描，确保食物不会出现在蛇身所在的位置。

#### 游戏结束的条件判定

&emsp;&emsp;在每次移动后检查蛇头的新位置是否与墙壁或蛇身的其他部分重叠。如果重叠，游戏结束。

#### 游戏的绘制

&emsp;&emsp;使用HTML的Canvas API或直接操作DOM来绘制游戏状态。在蛇移动或食物被吃掉时重新绘制影响的部分。

#### 交互反馈

&emsp;&emsp;更新显示得分和可能的游戏设置，如速度和区域大小。在游戏结束时显示最终得分并提供重新开始的选项。

#### 技术点

- **JavaScript事件处理**：用于处理键盘输入和游戏逻辑的更新。
- **DOM操作**：动态创建和修改游戏网格。
- **CSS样式**：控制游戏视觉表现，包括颜色、大小和过渡效果。
- **Canvas绘图**：绘制复杂的游戏元素，如转角和动画效果。

&emsp;&emsp;这种实现方式为游戏提供了足够的灵活性和扩展性，便于添加新功能如不同的游戏模式、改进的图形和额外的控制选项。

### 实验结果

👉 **[在线预览](https://slenderdata.github.io/HTML5-Learning/Experiment-8/GluttonousSnake.html)**

![截屏2024-05-12-21.12.07](https://raw.githubusercontent.com/SlenderData/img/main/images/2024/05/12/21-34-17-2da7317b91e2358f8c3dfb440d280423-截屏2024-05-12-21.12.07-a4cee4.png)

![截屏2024-05-12-21.13.55](https://raw.githubusercontent.com/SlenderData/img/main/images/2024/05/12/21-34-28-5298ea887ecbf8ef05c9472b8677269d-截屏2024-05-12-21.13.55-f7f3f0.png)

![截屏2024-05-12-21.19.56](https://raw.githubusercontent.com/SlenderData/img/main/images/2024/05/12/21-34-44-09544af9c36d8c02c160bceae5ab12ae-截屏2024-05-12-21.19.56-b4ffc8.png)

### 实验总结

&emsp;&emsp;在本次实验中，我设计并实现了贪吃蛇游戏，通过这个过程，我深入了解了游戏逻辑的设计、JavaScript的事件处理以及Canvas API的使用。这不仅加深了我对前端技术的认识，也锻炼了我的编程和问题解决技能。

&emsp;&emsp;首先，游戏的实现让我体会到了Canvas API的强大功能，特别是在绘制动态图像和处理游戏帧更新方面。我学会了如何使用Canvas来绘制蛇的移动，以及如何实时更新画面以响应用户的输入。这种视觉呈现不仅提高了游戏的互动性，也使得界面更加生动。

&emsp;&emsp;其次，JavaScript的事件监听功能在本实验中扮演了关键角色。我通过添加键盘事件监听，实现了对蛇的方向控制。这一过程不仅加深了我对事件驱动编程的理解，也提高了游戏的操作性和响应速度。

&emsp;&emsp;此外，我还学习了如何高效地管理DOM元素和游戏逻辑。游戏中蛇的每次移动都涉及到DOM的更新，这要求我能够精确地控制DOM元素的创建和销毁，从而保证游戏性能。通过这种方式，我更深刻地理解了DOM操作在动态网页应用中的重要性。

&emsp;&emsp;总的来说，这次实验不仅增强了我的技术技能，也激发了我继续探索更复杂游戏项目的兴趣。我期待将这些经验应用于未来的项目，进一步优化游戏性能和用户体验。这次实验是对我的编程能力的一次全面提升，同时也是对理论知识的实际应用。

<div style="page-break-after:always;"></div>

## 代码附件

### 实验五：饼状图和柱状图绘制

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>CanvasChart</title>
</head>
<style>
    body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", "PingFang SC", Arial, sans-serif;
        background-color: #D6E4E5;
        color: #333;
        padding: 0;
        margin: 0;
    }

    button {
        font-size: 1.1em;
        font-weight: bold;
        background-color: #D6E4E5;
        border: none;
        border-radius: 10px;
        cursor: pointer;
        padding: 10px;
        margin: 0 20px 0 20px;
        min-width: 6em;
    }

    th {
        background-color: #D6E4E5;
        font-weight: bold;
        width: 150px;
        height: 2em;
        border: 1px solid #333;
    }

    td {
        width: 150px;
        height: 1.5em;
        border: 1px solid #333;
        background-color: white;
    }

    .main {
        display: grid;
        grid-template-columns: 450px auto;
        justify-content: center;
        padding: 20px;
    }

    .inputArea {
        background-color: #EFF5F5;
        border-radius: 20px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        margin: 50px 0 0 50px;
        padding: 20px;
        height: 620px;
        float: left;
    }

    .drawArea {
        background-color: #EFF5F5;
        border-radius: 20px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        margin: 50px;
        padding: 20px;
        float: left;
        text-align: center;
    }
</style>
<body>
<div class="main">
    <div class="inputArea">
        <h1 style="text-align: center;">饼图和柱状图绘制</h1><br>
        <form>
            <label for="title">请输入图表标题：</label>
            <input type="text" id="title" style="width: 210px; height: 2em;">
            <br><br><br>
            <table id="inputTable" style="border: 1px solid #333; margin: auto;">
                <thead>
                <tr>
                    <th>类目名</th>
                    <th>数据值</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td contenteditable="true"></td>
                    <td contenteditable="true"></td>
                </tr>
                <tr>
                    <td contenteditable="true"></td>
                    <td contenteditable="true"></td>
                </tr>
                <tr>
                    <td contenteditable="true"></td>
                    <td contenteditable="true"></td>
                </tr>
                <tr>
                    <td contenteditable="true"></td>
                    <td contenteditable="true"></td>
                </tr>
                <tr>
                    <td contenteditable="true"></td>
                    <td contenteditable="true"></td>
                </tr>
                <tr>
                    <td contenteditable="true"></td>
                    <td contenteditable="true"></td>
                </tr>
                <tr>
                    <td contenteditable="true"></td>
                    <td contenteditable="true"></td>
                </tr>
                <tr>
                    <td contenteditable="true"></td>
                    <td contenteditable="true"></td>
                </tr>
                </tbody>
            </table>
            <br><br>
            <div style="text-align: center;">
                <button type="button" onclick="drawPieChart()">绘制饼图</button>
                <button type="button" onclick="drawBarChart()">绘制柱状图</button>
                <br><br>
                <button type="button" onclick="generateRandomData()">生成随机数据</button>
            </div>
        </form>
    </div>
    <div class="drawArea">
        <canvas id="canvasChart" width="1000" height="700"
                style="width: 1000px; height: 700px"></canvas>
    </div>
</div>
</body>
<script>
    // 填生成随机数据便于测试
    function generateRandomData() {
        let title = document.getElementById('title');
        title.value = '测试数据';
        let table = document.getElementById('inputTable');
        let rows = table.getElementsByTagName('tr');
        // 清空表格
        for (let i = 1; i < rows.length; i++) {
            let cells = rows[i].getElementsByTagName('td');
            cells[0].innerText = '';
            cells[1].innerText = '';
        }
        // 随机生成4-8组数据
        let num = Math.floor(Math.random() * 5) + 4;
        for (let i = 0; i < num; i++) {
            let cells = rows[i + 1].getElementsByTagName('td');
            cells[0].innerText = '类目' + (i + 1);
            cells[1].innerText = Math.floor(Math.random() * 100);
        }
    }

    // 随机选取用于数据可视化的颜色
    function chooseColor(numColor) {
        let color = ["#5470C6", "#91CC75", "#FAC858", "#EE6666", "#73C0DE", "#3BA272", "#FC8452", "#9A60D4"];
        // 打乱排序
        color.sort(function () {
            return Math.random() - 0.5;
        });
        // 返回前numColor个颜色
        return color.slice(0, numColor);
    }

    // 获取表数据，同时进行有效性检查，有效返回数据组，无效返回False
    function getTableData() {
        // 检查标题
        let title = document.getElementById("title").value;
        if (title === "") {
            alert("请输入图表标题！");
            return false;
        }
        let data = [];
        let table = document.getElementById("inputTable");
        // 跳过表头
        for (let i = 1; i < table.rows.length; i++) {
            let row = table.rows[i];
            // 跳过空白行
            if (row.cells[0].innerText === "" && row.cells[1].innerText === "") {
                continue;
            }
            // 类目名和数据值必须成对出现
            if (row.cells[0].innerText === "" || row.cells[1].innerText === "") {
                alert("请填写完整数据！");
                return false;
            }
            // 数据必须为数字
            if (isNaN(row.cells[1].innerText)) {
                alert("数据必须为数字！");
                return false;
            }
            data.push([row.cells[0].innerText, parseFloat(row.cells[1].innerText), 0]);
        }
        // 至少填写一组数据
        if (data.length === 0) {
            alert("请至少填写一组数据！");
            return false;
        }
        // 计算各数据的百分占比
        let sum = data.reduce((acc, cur) => acc + cur[1], 0);
        for (let i = 0; i < data.length; i++) {
            data[i][2] = data[i][1] / sum * 100;
        }
        return data;
    }

    // 获取高清屏幕的设备像素比
    const ratio = window.devicePixelRatio || 1;

    // 适配高清屏
    function createHDCanvas(canvas, w, h) {
        canvas.width = w * ratio; // 实际渲染像素
        canvas.height = h * ratio; // 实际渲染像素
        canvas.style.width = `${w}px`; // 控制显示大小
        canvas.style.height = `${h}px`; // 控制显示大小
        return canvas;
    }

    // 绘制饼图
    function drawPieChart() {
        let data = getTableData();
        if (data === false) {
            return;
        }
        let canvas = document.getElementById("canvasChart");
        canvas = createHDCanvas(canvas, 1000, 700);
        let ctx = canvas.getContext("2d");
        let width = canvas.width;
        let height = canvas.height;
        let centerX = width / 2;
        let centerY = height / 2;
        let radius = Math.min(width, height) / 2 - 100 * ratio;
        let sum = data.reduce((acc, cur) => acc + cur[1], 0);
        let startAngle = 0;
        let colors = chooseColor(data.length);
        // 绘制标题
        ctx.fillStyle = "#000000";
        ctx.font = "bold " + 30 * ratio + "px Arial";
        ctx.textAlign = "center";
        ctx.fillText(document.getElementById("title").value, centerX, 50 * ratio);
        for (let i = 0; i < data.length; i++) {
            // 绘制扇形
            let endAngle = startAngle + data[i][1] / sum * 2 * Math.PI;
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.arc(centerX, centerY, radius, startAngle, endAngle);
            ctx.closePath();
            ctx.fillStyle = colors[i];
            ctx.fill();
            // 绘制标签线
            let midAngle = (startAngle + endAngle) / 2;
            let x = centerX + Math.cos(midAngle) * radius;
            let y = centerY + Math.sin(midAngle) * radius;
            // 标签线宽度设置为1个单位像素
            ctx.lineWidth = 1 * ratio;
            ctx.beginPath();
            // 标签线起点定位到圆弧中点
            ctx.moveTo(x, y);
            // 向外延伸30个单位像素
            ctx.lineTo(x + Math.cos(midAngle) * 30 * ratio, y + Math.sin(midAngle) * 30 * ratio);
            // 根据圆弧中点的位置判断接下来标签线的水平延伸方向
            if (x > centerX) {
                // 向右延伸50个单位像素
                ctx.lineTo(x + Math.cos(midAngle) * 30 * ratio + 50 * ratio, y + Math.sin(midAngle) * 30 * ratio);
            } else {
                // 向左延伸50个单位像素
                ctx.lineTo(x + Math.cos(midAngle) * 30 * ratio - 50 * ratio, y + Math.sin(midAngle) * 30 * ratio);
            }
            ctx.stroke();
            // 绘制标签文字
            let tempText = data[i][0] + "  占比" + data[i][2].toFixed(2) + "%";
            // 设置字体大小为15个单位像素
            ctx.font = 15 * ratio + "px Arial";
            if (x > centerX) {
                ctx.textAlign = "left";
                ctx.fillText(tempText, x + Math.cos(midAngle) * 30 * ratio + 50 * ratio, y + Math.sin(midAngle) * 30 * ratio + 5 * ratio);
            } else {
                ctx.textAlign = "right";
                ctx.fillText(tempText, x + Math.cos(midAngle) * 30 * ratio - 50 * ratio, y + Math.sin(midAngle) * 30 * ratio + 5 * ratio);
            }
            startAngle = endAngle;
        }
    }

    // 绘制柱状图
    function drawBarChart() {
        let data = getTableData();
        if (data === false) {
            return;
        }
        let canvas = document.getElementById("canvasChart");
        canvas = createHDCanvas(canvas, 1000, 700);
        let ctx = canvas.getContext("2d");
        let width = canvas.width;
        let height = canvas.height;
        let barWidth = 50 * ratio;
        let barGap = 60 * ratio;
        let maxData = Math.max(...data.map(item => item[1]));
        let maxBarHeight = height - 250 * ratio;
        let colors = chooseColor(1);
        // 绘制标题
        ctx.fillStyle = "#000000";
        ctx.font = "bold " + 30 * ratio + "px Arial";
        ctx.textAlign = "center";
        ctx.fillText(document.getElementById("title").value, width / 2, 50 * ratio);
        // 绘制x轴参考线，左右超出30个单位像素
        let startX = (width - (barWidth + barGap) * data.length + barGap) / 2;
        ctx.lineWidth = 2 * ratio;
        ctx.beginPath();
        ctx.moveTo(startX - 30 * ratio, height - 100 * ratio);
        ctx.lineTo(width - startX + 30 * ratio, height - 100 * ratio);
        ctx.stroke();
        // 绘制x轴箭头
        ctx.beginPath();
        ctx.moveTo(width - startX + 30 * ratio, height - 100 * ratio);
        ctx.lineTo(width - startX + 20 * ratio, height - 105 * ratio);
        ctx.lineTo(width - startX + 20 * ratio, height - 95 * ratio);
        ctx.closePath();
        ctx.fill();
        // 绘制y轴参考线
        ctx.beginPath();
        ctx.moveTo(startX - 30 * ratio, height - 100 * ratio);
        ctx.lineTo(startX - 30 * ratio, 100 * ratio);
        ctx.stroke();
        // 绘制y轴箭头
        ctx.beginPath();
        ctx.moveTo(startX - 30 * ratio, 100 * ratio);
        ctx.lineTo(startX - 35 * ratio, 110 * ratio);
        ctx.lineTo(startX - 25 * ratio, 110 * ratio);
        ctx.closePath();
        ctx.fill();
        // 绘制y轴元素
        ctx.font = 15 * ratio + "px Arial";
        ctx.textAlign = "right";
        for (let i = 0; i <= maxData; i += maxData / 4) {
            let y = height - 100 * ratio - i / maxData * maxBarHeight;
            // 绘制y轴网格线
            ctx.setLineDash([5, 5]);
            if (i === 0) {
                continue;
            } else {
                ctx.strokeStyle = "#D3D3D3";
            }
            ctx.beginPath();
            ctx.moveTo(startX - 30 * ratio, y);
            ctx.lineTo(width - startX + 30 * ratio, y);
            ctx.stroke();
            // 绘制y轴刻度
            ctx.setLineDash([])
            ctx.strokeStyle = "#000000";
            ctx.beginPath();
            ctx.moveTo(startX - 25 * ratio, y);
            ctx.lineTo(startX - 35 * ratio, y);
            ctx.stroke();
            ctx.fillText(i, startX - 40 * ratio, y + 5 * ratio);
        }
        // 绘制柱状图，整体在x轴方向居中
        for (let i = 0; i < data.length; i++) {
            let barHeight = data[i][1] / maxData * maxBarHeight;
            let startY = height - 101 * ratio - barHeight;
            // 绘制柱状图
            ctx.fillStyle = colors[0];
            ctx.fillRect(startX + i * (barWidth + barGap), startY, barWidth, barHeight);
            // 绘制标签文字
            ctx.fillStyle = "#000000";
            ctx.font = 15 * ratio + "px Arial";
            ctx.textAlign = "center";
            ctx.fillText(data[i][0], startX + i * (barWidth + barGap) + barWidth / 2, height - 75 * ratio);
            ctx.fillText(data[i][1], startX + i * (barWidth + barGap) + barWidth / 2, startY - 5 * ratio);
        }
    }
</script>
</html>

```

<div style="page-break-after:always;"></div>

### 实验六：视频播放器设计

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>VideoPlayer</title>
</head>
<style>
    body {
        font-family: -apple-system, "Helvetica Neue", "PingFang SC", "Apple Color Emoji", "Segoe UI Emoji", BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
        background-color: #D6E4E5;
        color: #333;
        padding: 0;
        margin: 0;
    }

    button {
        font-size: 1.2em;
        background-color: #D6E4E5;
        border: none;
        border-radius: 10px;
        cursor: pointer;
        padding: 10px;
        margin: 10px 10px 0 10px;
        min-width: 3em;
    }

    .main {
        display: grid;
        grid-template-columns: auto auto;
        justify-content: center;
        padding: 20px;
    }

    .infoArea {
        background-color: #EFF5F5;
        border-radius: 20px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        margin-left: 20px;
        margin-top: 20px;
        padding: 10px;
        padding-bottom: 1em;
        float: left;
        text-align: center;
        height: fit-content;
        width: fit-content;
    }

    #videoList {
        table-layout: fixed;
        width: 340px;
        margin: 0 auto;
    }

    #videoList td {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        text-align: left;
        font-size: 1.1em;
    }

    .playerArea {
        background-color: #EFF5F5;
        border-radius: 20px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        margin: 20px;
        padding: 10px;
        float: left;
        text-align: center;
        height: fit-content;
        width: fit-content;
    }

    video {
        border-radius: 15px;
        background-image: url("https://github.com/SlenderData/HTML5-Learning/blob/main/Experiment-6/resource/Loading.png?raw=true");
        background-size: 100% 100%;
    }

</style>
<body>
<div class="main">
    <div class="infoArea">
        <img src="" id="cover" alt="Cover" style="width: 400px; height: 400px; border-radius: 15px;">
        <h2 id="title" style="margin: 0.5em;"></h2>
        <h3 id="album" style="margin: 0.5em;"></h3>
        <h3 id="artist" style="margin: 0.5em;"></h3>
        <hr>
        <h3 style="text-align: left; margin: 1em 0 0.75em 1.75em;">即将播放</h3>
        <table id="videoList">
            <tr>
                <td style="width: 1.5em;">1️⃣</td>
                <td></td>
            </tr>
            <tr>
                <td>2️⃣</td>
                <td></td>
            </tr>
            <tr>
                <td>3️⃣</td>
                <td></td>
            </tr>
            <tr>
                <td>4️⃣</td>
                <td></td>
            </tr>
            <tr>
                <td>5️⃣</td>
                <td></td>
            </tr>
            <tr>
                <td>6️⃣</td>
                <td></td>
            </tr>
            <tr>
                <td>7️⃣</td>
                <td></td>
            </tr>
            <tr>
                <td>8️⃣</td>
                <td></td>
            </tr>
            <tr>
                <td>9️⃣</td>
                <td></td>
            </tr>
        </table>
    </div>
    <div class="playerArea">
        <video id="video" width="1360" height="765">
            Your browser does not support the video tag.
        </video>
        <div>
            <button id="volumeButton" onclick="toggleVolume()">🔊</button>
            <button id="zoomOutButton" onclick="zoomOut()">➖</button>
            <button id="prevButton" onclick="prevVideo()">⏮️</button>
            <button id="rewindButton" onclick="rewind(10)">⏪</button>
            <button id="playPauseButton" onclick="playPause()">▶️</button>
            <button id="fastForwardButton" onclick="fastForward(10)">⏩</button>
            <button id="nextButton" onclick="nextVideo()">⏭️</button>
            <button id="zoomInButton" onclick="zoomIn()">➕</button>
            <button id="fullScreenButton" onclick="fullScreen()">全屏</button>
        </div>
    </div>
</div>
</body>
<script>
    // // 初始化播放列表（外链版）
    // const videos = [
    //     {
    //         videoUrl: "https://github.com/SlenderData/HTML5-Learning/blob/main/Experiment-6/resource/VinylRecords/The_greatest_-_Lana_Del_Rey.mp4?raw=true",
    //         coverUrl: "https://github.com/SlenderData/HTML5-Learning/blob/main/Experiment-6/resource/AlbumCovers/Norman_Fucking_Rockwell!.jpg?raw=true",
    //         title: "The greatest",
    //         album: "Norman Fucking Rockwell!",
    //         artist: "Lana Del Rey"
    //     },
    //     {
    //         videoUrl: "https://github.com/SlenderData/HTML5-Learning/blob/main/Experiment-6/resource/VinylRecords/A&W_-_Lana_Del_Rey.mp4?raw=true",
    //         coverUrl: "https://github.com/SlenderData/HTML5-Learning/blob/main/Experiment-6/resource/AlbumCovers/Did_you_know_that_there's_a_tunnel_under_Ocean_Blvd.jpg?raw=true",
    //         title: "A&W",
    //         album: "Did you know that there's a tunnel under Ocean Blvd",
    //         artist: "Lana Del Rey"
    //     },
    //     {
    //         videoUrl: "https://github.com/SlenderData/HTML5-Learning/blob/main/Experiment-6/resource/VinylRecords/34+35_-_Ariana_Grande.mp4?raw=true",
    //         coverUrl: "https://github.com/SlenderData/HTML5-Learning/blob/main/Experiment-6/resource/AlbumCovers/Positions.jpg?raw=true",
    //         title: "34+35",
    //         album: "Positions",
    //         artist: "Ariana Grande"
    //     },
    //     {
    //         videoUrl: "https://github.com/SlenderData/HTML5-Learning/blob/main/Experiment-6/resource/VinylRecords/Honeymoon_Avenue_-_Ariana_Grande.mp4?raw=true",
    //         coverUrl: "https://github.com/SlenderData/HTML5-Learning/blob/main/Experiment-6/resource/AlbumCovers/Yours_Truly.jpg?raw=true",
    //         title: "Honeymoon Avenue",
    //         album: "Yours Truly",
    //         artist: "Ariana Grande"
    //     },
    //     {
    //         videoUrl: "https://github.com/SlenderData/HTML5-Learning/blob/main/Experiment-6/resource/VinylRecords/Judas_-_Lady_Gaga.mp4?raw=true",
    //         coverUrl: "https://github.com/SlenderData/HTML5-Learning/blob/main/Experiment-6/resource/AlbumCovers/Born_This_Way.jpg?raw=true",
    //         title: "Judas",
    //         album: "Born This Way",
    //         artist: "Lady Gaga"
    //     },
    //     {
    //         videoUrl: "https://github.com/SlenderData/HTML5-Learning/blob/main/Experiment-6/resource/VinylRecords/Rolling_In_The_Deep_-_Adele.mp4?raw=true",
    //         coverUrl: "https://github.com/SlenderData/HTML5-Learning/blob/main/Experiment-6/resource/AlbumCovers/21.jpg?raw=true",
    //         title: "Rolling In The Deep",
    //         album: "21",
    //         artist: "Adele"
    //     },
    //     {
    //         videoUrl: "https://github.com/SlenderData/HTML5-Learning/blob/main/Experiment-6/resource/VinylRecords/Getaway_Car_-_Taylor_Swift.mp4?raw=true",
    //         coverUrl: "https://github.com/SlenderData/HTML5-Learning/blob/main/Experiment-6/resource/AlbumCovers/reputation.jpg?raw=true",
    //         title: "Getaway Car",
    //         album: "reputation",
    //         artist: "Taylor Swift"
    //     },
    //     {
    //         videoUrl: "https://github.com/SlenderData/HTML5-Learning/blob/main/Experiment-6/resource/VinylRecords/Cruel_Summer_-_Taylor_Swift.mp4?raw=true",
    //         coverUrl: "https://github.com/SlenderData/HTML5-Learning/blob/main/Experiment-6/resource/AlbumCovers/Lover.jpg?raw=true",
    //         title: "Cruel Summer",
    //         album: "Lover",
    //         artist: "Taylor Swift"
    //     },
    //     {
    //         videoUrl: "https://github.com/SlenderData/HTML5-Learning/blob/main/Experiment-6/resource/VinylRecords/august_-_Taylor_Swift.mp4?raw=true",
    //         coverUrl: "https://github.com/SlenderData/HTML5-Learning/blob/main/Experiment-6/resource/AlbumCovers/folklore.jpg?raw=true",
    //         title: "august",
    //         album: "folklore",
    //         artist: "Taylor Swift"
    //     },
    //     {
    //         videoUrl: "https://github.com/SlenderData/HTML5-Learning/blob/main/Experiment-6/resource/VinylRecords/All_Too_Well_(10_Minute_Version)_(Taylor's_Version)_-_Taylor_Swift.mp4?raw=true",
    //         coverUrl: "https://github.com/SlenderData/HTML5-Learning/blob/main/Experiment-6/resource/AlbumCovers/Red_(Taylor's_Version).jpg?raw=true",
    //         title: "All Too Well (10 Minute Version) (Taylor's Version)",
    //         album: "Red (Taylor's Version)",
    //         artist: "Taylor Swift"
    //     }
    // ];

    // 初始化播放列表（内链版）
    const videos = [
        {
            videoUrl: "resource/VinylRecords/The_greatest_-_Lana_Del_Rey.mp4",
            coverUrl: "resource/AlbumCovers/Norman_Fucking_Rockwell!.jpg",
            title: "The greatest",
            album: "Norman Fucking Rockwell!",
            artist: "Lana Del Rey"
        },
        {
            videoUrl: "resource/VinylRecords/A&W_-_Lana_Del_Rey.mp4",
            coverUrl: "resource/AlbumCovers/Did_you_know_that_there's_a_tunnel_under_Ocean_Blvd.jpg",
            title: "A&W",
            album: "Did you know that there's a tunnel under Ocean Blvd",
            artist: "Lana Del Rey"
        },
        {
            videoUrl: "resource/VinylRecords/34+35_-_Ariana_Grande.mp4",
            coverUrl: "resource/AlbumCovers/Positions.jpg",
            title: "34+35",
            album: "Positions",
            artist: "Ariana Grande"
        },
        {
            videoUrl: "resource/VinylRecords/Honeymoon_Avenue_-_Ariana_Grande.mp4",
            coverUrl: "resource/AlbumCovers/Yours_Truly.jpg",
            title: "Honeymoon Avenue",
            album: "Yours Truly",
            artist: "Ariana Grande"
        },
        {
            videoUrl: "resource/VinylRecords/Judas_-_Lady_Gaga.mp4",
            coverUrl: "resource/AlbumCovers/Born_This_Way.jpg",
            title: "Judas",
            album: "Born This Way",
            artist: "Lady Gaga"
        },
        {
            videoUrl: "resource/VinylRecords/Rolling_In_The_Deep_-_Adele.mp4",
            coverUrl: "resource/AlbumCovers/21.jpg",
            title: "Rolling In The Deep",
            album: "21",
            artist: "Adele"
        },
        {
            videoUrl: "resource/VinylRecords/Getaway_Car_-_Taylor_Swift.mp4",
            coverUrl: "resource/AlbumCovers/reputation.jpg",
            title: "Getaway Car",
            album: "reputation",
            artist: "Taylor Swift"
        },
        {
            videoUrl: "resource/VinylRecords/Cruel_Summer_-_Taylor_Swift.mp4",
            coverUrl: "resource/AlbumCovers/Lover.jpg",
            title: "Cruel Summer",
            album: "Lover",
            artist: "Taylor Swift"
        },
        {
            videoUrl: "resource/VinylRecords/august_-_Taylor_Swift.mp4",
            coverUrl: "resource/AlbumCovers/folklore.jpg",
            title: "august",
            album: "folklore",
            artist: "Taylor Swift"
        },
        {
            videoUrl: "resource/VinylRecords/All_Too_Well_(10_Minute_Version)_(Taylor's_Version)_-_Taylor_Swift.mp4",
            coverUrl: "resource/AlbumCovers/Red_(Taylor's_Version).jpg",
            title: "All Too Well (10 Minute Version) (Taylor's Version)",
            album: "Red (Taylor's Version)",
            artist: "Taylor Swift"
        }
    ];

    // 打乱播放列表
    videos.sort(() => Math.random() - 0.5);

    // 初始化
    function initPlayer() {
        let currentCover = document.getElementById("cover");
        let currentTitle = document.getElementById("title");
        let currentAlbum = document.getElementById("album");
        let currentArtist = document.getElementById("artist");
        let currentVideo = document.getElementById("video");
        currentCover.src = videos[0].coverUrl;
        currentTitle.innerText = videos[0].title;
        currentAlbum.innerText = videos[0].album;
        currentArtist.innerText = videos[0].artist;
        currentVideo.src = videos[0].videoUrl;
        // 更新播放列表
        updateVideoList();
        // 对video元素添加事件监听，如果结束就播放下一个视频
        currentVideo.addEventListener("ended", function () {
            nextVideo();
        });
        // 对video的音量添加事件监听
        currentVideo.addEventListener("volumechange", function () {
            if (currentVideo.muted) {
                document.getElementById("volumeButton").innerText = "🔇";
            } else {
                document.getElementById("volumeButton").innerText = "🔊";
            }
        });
        // 对video的播放状态添加事件监听
        currentVideo.addEventListener("play", function () {
            document.getElementById("playPauseButton").innerText = "⏸️";
        });
        currentVideo.addEventListener("pause", function () {
            document.getElementById("playPauseButton").innerText = "▶️";
        });
    }

    initPlayer();

    // 切换视频
    function switchVideo(index, flag) {
        if (flag) {
            videos.unshift(videos.splice(index, 1)[0]);
        } else {
            videos.push(videos.shift());
            videos.unshift(videos.splice(index - 1, 1)[0]);
        }
        let video = document.getElementById("video");
        let currentCover = document.getElementById("cover");
        let currentTitle = document.getElementById("title");
        let currentAlbum = document.getElementById("album");
        let currentArtist = document.getElementById("artist");
        currentCover.src = videos[0].coverUrl;
        currentTitle.innerText = videos[0].title;
        currentAlbum.innerText = videos[0].album;
        currentArtist.innerText = videos[0].artist;
        video.src = videos[0].videoUrl;
        updateVideoList();
        video.play();
    }

    // 更新播放列表
    function updateVideoList() {
        let videoList = document.getElementById("videoList");
        for (let i = 1; i < videos.length; i++) {
            let row = videoList.rows[i - 1];
            row.cells[1].innerText = videos[i].title;
            row.cells[1].title = videos[i].title;
            row.cells[1].onclick = function () {
                switchVideo(i, false);
            };
        }
    }

    // 切换声音状态
    function toggleVolume() {
        let video = document.getElementById("video");
        video.muted = !video.muted;
    }

    // 缩小播放器
    function zoomOut() {
        let video = document.getElementById("video");
        if (video.width > 752 && video.height > 423) {
            video.width = Math.max(video.width * 0.8, 752);
            video.height = Math.max(video.height * 0.8, 423);
        } else {
            alert("已经缩小到最小尺寸！");
        }
    }

    // 放大播放器
    function zoomIn() {
        let video = document.getElementById("video");
        if (video.width < 1360 && video.height < 765) {
            video.width = Math.min(video.width * 1.25, 1360);
            video.height = Math.min(video.height * 1.25, 765);
        } else {
            alert("已经放大到最大尺寸！");
        }
    }

    // 切换上一个视频
    function prevVideo() {
        switchVideo(videos.length - 1, true);
    }

    // 切换下一个视频
    function nextVideo() {
        switchVideo(1, false);
    }

    // 快进
    function fastForward(seconds) {
        let video = document.getElementById("video");
        video.currentTime += seconds;
    }

    // 快退
    function rewind(seconds) {
        let video = document.getElementById("video");
        video.currentTime -= seconds;
    }

    // 播放/暂停
    function playPause() {
        let video = document.getElementById("video");
        if (video.paused) {
            video.play();
        } else {
            video.pause();
        }
    }

    // 全屏
    function fullScreen() {
        video.requestFullscreen();
    }

</script>
</html>

```

<div style="page-break-after:always;"></div>

### 实验七：响应式放大悬浮菜单

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>CSS3Menu</title>
</head>
<style>
    @font-face {
        font-family: "big-caslon-fb";
        src: url("resource/font/big-caslon-fb-700.woff2") format("woff2"), url("resource/font/big-caslon-fb-700.woff") format("woff");
        font-display: auto;
        font-style: normal;
        font-weight: 700;
        font-stretch: normal
    }

    @font-face {
        font-family: "big-caslon-fb";
        src: url("resource/font/big-caslon-fb-400.woff2") format("woff2"), url("resource/font/big-caslon-fb-400.woff") format("woff");
        font-display: auto;
        font-style: normal;
        font-weight: 400;
        font-stretch: normal
    }

    body {
        font-family: "big-caslon-fb", -apple-system, "Helvetica Neue", "PingFang SC", "Apple Color Emoji", "Segoe UI Emoji", BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
        color: #625548;
        background-color: #EEEDE9;
        background-image: url("resource/background.png");
        background-size: cover;
        background-attachment: fixed;
        background-position: center;
        letter-spacing: 0.1em;
    }

    .main {
        display: grid;
        grid-template-columns: auto auto;
        justify-content: center;
        padding: 20px;
    }

    .info {
        background-color: rgba(238, 237, 233, 0.7);
        border-radius: 20px;
        box-shadow: 0 4px 8px rgba(51, 43, 36, 0.2);
        margin: 20px;
        padding: 20px;
        width: fit-content;
        height: fit-content;
        text-align: center;
        font-weight: 700;
    }

    .tracks {
        background-color: rgba(238, 237, 233, 0.7);
        border-radius: 20px;
        box-shadow: 0 4px 8px rgba(51, 43, 36, 0.2);
        margin: 20px;
        padding: 20px;
        width: fit-content;
        height: fit-content;
        font-weight: 400;
    }

    ul {
        padding: 0;
        list-style: decimal inside;
    }

    li {
        padding: 10px;
        margin: 10px auto;
        font-size: 1.1em;
        line-height: 30px;
        background-color: rgba(238, 237, 233, 0.5);
        box-shadow: 0 0 10px rgba(51, 43, 36, 0);
        border-radius: 10px;
        height: 30px;
        width: 600px;
        transition: 0.5s;
    }

    li:hover {
        padding: 10px;
        margin: 10px auto;
        font-size: 1.5em;
        line-height: 40px;
        border-radius: 10px;
        height: 40px;
        width: 630px;
        background-color: rgba(238, 237, 233, 0.7);
        box-shadow: 0 0 25px rgba(51, 43, 36, 0.4);
        transition: 0.5s;
    }

</style>
<body>
<div class="main">
    <div class="info">
        <img src="resource/cover.jpg" id="cover" alt="Cover" style="width: 400px; height: 400px; border-radius: 15px;">
        <h1 style="margin-bottom: 0.2em; letter-spacing: 0.05em;">THE TORTURED<br>POETS DEPARTMENT</h1>
        <h2 style="margin-top: 0; letter-spacing: 0.2em;">THE ANTHOLOGY</h2>
        <h2>Taylor Swift</h2>
    </div>
    <div class="tracks">
        <h2 style="text-align: center;">Track List</h2>
        <ul>
            <li>Fortnight (feat. Post Malone)</li>
            <li>The Tortured Poets Department</li>
            <li>My Boy Only Breaks His Favorite Toys</li>
            <li>Down Bad</li>
            <li>So Long, London</li>
            <li>But Daddy I Love Him</li>
            <li>Fresh Out The Slammer</li>
            <li>Florida!!! (feat. Florence + the Machine)</li>
            <li>Guilty as Sin?</li>
            <li>Who's Afraid of Little Old Me?</li>
            <li>I Can Fix Him (No Really I Can)</li>
            <li>loml</li>
            <li>I Can Do It With a Broken Heart</li>
            <li>The Smallest Man Who Ever Lived</li>
            <li>The Alchemy</li>
            <li>Clara Bow</li>
            <li>The Black Dog</li>
            <li>imgonnagetyouback</li>
            <li>The Albatross</li>
            <li>Chloe or Sam or Sophia or Marcus</li>
            <li>How Did It End?</li>
            <li>So High School</li>
            <li>I Hate It Here</li>
            <li>thanK you aIMee</li>
            <li>I Look in People's Windows</li>
            <li>The Prophecy</li>
            <li>Cassandra</li>
            <li>Peter</li>
            <li>The Bolter</li>
            <li>Robin</li>
            <li>The Manuscript</li>
        </ul>
    </div>
</div>
</body>
</html>

```

<div style="page-break-after:always;"></div>

### 实验八：贪吃蛇小游戏设计与实现

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>GluttonousSnake</title>
</head>
<style>
    body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", "PingFang SC", Arial, sans-serif;
        background-color: #D6E4E5;
        color: #333;
        padding: 0;
        margin: 0;
    }

    button {
        font-size: 1.1em;
        font-weight: bold;
        background-color: #D6E4E5;
        border: none;
        border-radius: 10px;
        cursor: pointer;
        padding: 10px;
        margin: 20px auto;
        text-align: center;
        display: block;
    }

    #main {
        display: grid;
        grid-template-columns: auto auto;
        justify-content: center;
        padding: 20px;
    }

    #inputArea {
        background-color: #EFF5F5;
        border-radius: 20px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        margin: 50px 0 0 50px;
        padding: 20px;
        height: fit-content;
        width: fit-content;
        float: left;
    }

    #gameArea {
        background-color: #EFF5F5;
        border-radius: 20px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        margin: 50px;
        padding: 20px;
        height: fit-content;
        width: fit-content;
        float: left;
        white-space: nowrap;
    }

    #gameArea div {
        float: left;
        background-color: #eee;
    }
</style>
<body>
<div id="main">
    <div id="inputArea">
        <h1 style="text-align: center;">贪吃蛇游戏</h1>
        <h3 style="text-align: center;">当前得分：<span id="score">0</span></h3>
        <table>
            <tr>
                <td style="text-align: right;"><label for="speed">刷新速度（ms）：</label></td>
                <td><input type="number" id="speed" value="500" min="1"
                           oninput="this.value = this.value.replace(/\D/g, '')"></td>
            </tr>
            <tr>
                <td style="text-align: right;"><label for="cellLength">格子边长（px）：</label></td>
                <td><input type="number" id="cellLength" value="64" min="1"
                           oninput="this.value = this.value.replace(/\D/g, '')" onchange="resetGameArea()"></td>
            </tr>
            <tr>
                <td style="text-align: right;"><label for="cellMargin">格子间距（px）：</label></td>
                <td><input type="number" id="cellMargin" value="0" min="0"
                           oninput="this.value = this.value.replace(/\D/g, '')" onchange="resetGameArea()"></td>
            </tr>
            <tr>
                <td style="text-align: right;"><label for="gameAreaWidth">宽度（格）：</label></td>
                <td><input type="number" id="gameAreaWidth" value="8" min="3"
                           oninput="this.value = this.value.replace(/\D/g, '')" onchange="resetGameArea()"></td>
            </tr>
            <tr>
                <td style="text-align: right;"><label for="gameAreaHeight">高度（格）：</label></td>
                <td><input type="number" id="gameAreaHeight" value="8" min="3"
                           oninput="this.value = this.value.replace(/\D/g, '')" onchange="resetGameArea()"></td>
            </tr>
        </table>
        <button id="start" onclick="startGame()">开始游戏</button>
    </div>
    <div id="gameArea">
    </div>
</div>
</body>
<script>
    // 节点类
    class Node {
        constructor(type, row, col) {
            this.type = type;
            this.row = row;
            this.col = col;
            this.prev = null;
            this.next = null;
        }
    }

    // 双向链表类
    class DoublyLinkedList {
        constructor() {
            this.head = null;
            this.tail = null;
            this.length = 0;
        }

        // 链表尾部添加一个新节点
        append(node) {
            if (this.length === 0) {
                this.head = node;
                this.tail = node;
            } else {
                this.tail.next = node;
                node.prev = this.tail;
                this.tail = node;
            }
            this.length++;
        }

        // 链表头部添加一个新节点
        prepend(node) {
            if (this.length === 0) {
                this.head = node;
                this.tail = node;
            } else {
                this.head.prev = node;
                node.next = this.head;
                this.head = node;
            }
            this.length++;
        }

        // 删除链表尾部节点
        pop() {
            if (this.length === 0) {
                return null;
            }
            let node = this.tail;
            if (this.length === 1) {
                this.head = null;
                this.tail = null;
            } else {
                this.tail = this.tail.prev;
                this.tail.next = null;
            }
            this.length--;
            return node;
        }

    }

    // 食物节点类
    class FoodNode extends Node {
        constructor() {
            super();
        }

        init() {
            let gameAreaWidth = Number(document.getElementById("gameAreaWidth").value);
            let gameAreaHeight = Number(document.getElementById("gameAreaHeight").value);
            // 检查是否存在空白格子
            let empty = false;
            for (let i = 1; i <= gameAreaHeight; i++) {
                for (let j = 1; j <= gameAreaWidth; j++) {
                    if (checkCellEmpty(i, j)) {
                        empty = true;
                        break;
                    }
                }
                if (empty) {
                    break;
                }
            }
            if (!empty) {
                console.log("没有空白格子了！");
                return null;
            }
            // 在空白格子中随机生成食物
            do {
                this.row = Math.floor(Math.random() * gameAreaHeight) + 1;
                this.col = Math.floor(Math.random() * gameAreaWidth) + 1;
            } while (!checkCellEmpty(this.row, this.col));
            this.type = "Food";
            return this;
        }

        display() {
            drawCanvas(document.getElementById("cell-" + this.row + "-" + this.col), "Food", 0);
        }
    }

    // 墙节点类
    class WallNodes extends DoublyLinkedList {
        constructor() {
            super();
        }

        init() {
            let gameAreaWidth = Number(document.getElementById("gameAreaWidth").value);
            let gameAreaHeight = Number(document.getElementById("gameAreaHeight").value);
            //设置墙节点，从左上角开始顺时针存储为双向环链
            for (let i = 0; i < gameAreaWidth + 2; i++) {
                let node = new Node("Wall", 0, i);
                this.append(node);
            }
            for (let i = 1; i < gameAreaHeight + 2; i++) {
                let node = new Node("Wall", i, gameAreaWidth + 1);
                this.append(node);
            }
            for (let i = gameAreaWidth; i >= 0; i--) {
                let node = new Node("Wall", gameAreaHeight + 1, i);
                this.append(node);
            }
            for (let i = gameAreaHeight; i >= 1; i--) {
                let node = new Node("Wall", i, 0);
                this.append(node);
            }
            this.head.prev = this.tail;
            this.tail.next = this.head;
            return this;
        }

        display() {
            let gameAreaWidth = Number(document.getElementById("gameAreaWidth").value);
            let gameAreaHeight = Number(document.getElementById("gameAreaHeight").value);
            let currentNode = this.head;
            do {
                let cell = document.getElementById("cell-" + currentNode.row + "-" + currentNode.col);
                if (currentNode.row === 0 && currentNode.col === 0) {
                    drawCanvas(cell, "WallCorner", 270);
                } else if (currentNode.row === 0 && currentNode.col === gameAreaWidth + 1) {
                    drawCanvas(cell, "WallCorner", 0);
                } else if (currentNode.row === gameAreaHeight + 1 && currentNode.col === 0) {
                    drawCanvas(cell, "WallCorner", 180);
                } else if (currentNode.row === gameAreaHeight + 1 && currentNode.col === gameAreaWidth + 1) {
                    drawCanvas(cell, "WallCorner", 90);
                } else if (currentNode.row === 0) {
                    drawCanvas(cell, "Wall", 0);
                } else if (currentNode.col === 0) {
                    drawCanvas(cell, "Wall", 270);
                } else if (currentNode.row === gameAreaHeight + 1) {
                    drawCanvas(cell, "Wall", 180);
                } else if (currentNode.col === gameAreaWidth + 1) {
                    drawCanvas(cell, "Wall", 90);
                }
                currentNode = currentNode.next;
            } while (currentNode !== this.head)
        }
    }

    // 蛇节点类
    class SnakeList extends DoublyLinkedList {
        constructor() {
            super();
            this.headDirection = null;
        }

        init() {
            let body = new Node("Snake", 2, 1);
            this.append(body);
            body = new Node("Snake", 1, 1);
            this.append(body);
            this.headDirection = "down";
            return this;
        }

        display() {
            let currentNode = this.head;
            while (currentNode !== null) {
                let cell = document.getElementById("cell-" + currentNode.row + "-" + currentNode.col);
                let prevNode = currentNode.prev;
                let nextNode = currentNode.next;
                if (currentNode === this.head) {
                    if (currentNode.row === nextNode.row) {
                        if (currentNode.col < nextNode.col) {
                            drawCanvas(cell, "SnakeHead", 270);
                        } else {
                            drawCanvas(cell, "SnakeHead", 90);
                        }
                    } else {
                        if (currentNode.row < nextNode.row) {
                            drawCanvas(cell, "SnakeHead", 0);
                        } else {
                            drawCanvas(cell, "SnakeHead", 180);
                        }
                    }
                } else if (currentNode === this.tail) {
                    if (currentNode.row === prevNode.row) {
                        if (currentNode.col > prevNode.col) {
                            drawCanvas(cell, "SnakeTail", 270);
                        } else {
                            drawCanvas(cell, "SnakeTail", 90);
                        }
                    } else {
                        if (currentNode.row > prevNode.row) {
                            drawCanvas(cell, "SnakeTail", 0);
                        } else {
                            drawCanvas(cell, "SnakeTail", 180);
                        }
                    }
                } else {
                    if (currentNode.row === prevNode.row && currentNode.row === nextNode.row) {
                        if (currentNode.col > prevNode.col) {
                            drawCanvas(cell, "SnakeBodyStraight", 270);
                        } else {
                            drawCanvas(cell, "SnakeBodyStraight", 90);
                        }
                    } else if (currentNode.col === prevNode.col && currentNode.col === nextNode.col) {
                        if (currentNode.row < nextNode.row) {
                            drawCanvas(cell, "SnakeBodyStraight", 0);
                        } else {
                            drawCanvas(cell, "SnakeBodyStraight", 180);
                        }
                    } else {
                        drawCanvas(cell, "SnakeBodyBend", 0);
                        let canvas = cell.children[0];
                        if (currentNode.row === prevNode.row) {
                            if (currentNode.col > prevNode.col) {
                                if (currentNode.row < nextNode.row) {
                                    canvas.style.transform = "rotate(0deg) rotateX(0deg)";
                                } else {
                                    canvas.style.transform = "rotate(0deg) rotateX(180deg)";
                                }
                            } else {
                                if (currentNode.row > nextNode.row) {
                                    canvas.style.transform = "rotate(180deg) rotateX(0deg)";
                                } else {
                                    canvas.style.transform = "rotate(180deg) rotateX(180deg)";
                                }
                            }
                        } else if (currentNode.col === prevNode.col) {
                            if (currentNode.row > prevNode.row) {
                                if (currentNode.col > nextNode.col) {
                                    canvas.style.transform = "rotate(90deg) rotateX(0deg)";
                                } else {
                                    canvas.style.transform = "rotate(90deg) rotateX(180deg)";
                                }
                            } else {
                                if (currentNode.col < nextNode.col) {
                                    canvas.style.transform = "rotate(270deg) rotateX(0deg)";
                                } else {
                                    canvas.style.transform = "rotate(270deg) rotateX(180deg)";
                                }
                            }
                        }
                    }
                }
                currentNode = currentNode.next;
            }
        }

        move(targetDirection) {
            let tempNode = this.pop();
            // 清空tempNode所在的格子
            document.getElementById("cell-" + tempNode.row + "-" + tempNode.col).innerHTML = "";
            // 根据目标方向设置新的头部方向
            if (targetDirection === null ||
                targetDirection === "left" && this.headDirection === "right" ||
                targetDirection === "right" && this.headDirection === "left" ||
                targetDirection === "up" && this.headDirection === "down" ||
                targetDirection === "down" && this.headDirection === "up") {
                // headDirection不变
            } else {
                this.headDirection = targetDirection;
            }
            // 根据headDirection设置新的头部位置
            let newHead = new Node("Snake", this.head.row, this.head.col);
            if (this.headDirection === "left") {
                newHead.col--;
            } else if (this.headDirection === "right") {
                newHead.col++;
            } else if (this.headDirection === "up") {
                newHead.row--;
            } else if (this.headDirection === "down") {
                newHead.row++;
            }
            // 判断是否是食物
            if (checkCellFood(newHead.row, newHead.col)) {
                // 将食物格清空
                document.getElementById("cell-" + newHead.row + "-" + newHead.col).innerHTML = "";
                // 是食物，将尾部加回去
                this.append(tempNode);
                this.prepend(newHead);
                this.display();
                // 加分
                let score = Number(document.getElementById("score").innerText);
                document.getElementById("score").innerText = score + 1;
                // 重新生成食物
                let food = new FoodNode().init();
                food.display();
            } else if (checkCellEmpty(newHead.row, newHead.col)) {
                // 是空白格子，继续前进
                this.prepend(newHead);
                this.display();
            } else {
                // 将尾部加回去
                this.append(tempNode);
                this.display();
                // 是墙或者是自己，游戏结束
                alert("游戏结束！得分：" + document.getElementById("score").innerText);
                gameStart = false;
                // 将游戏区域设置解锁
                document.getElementById("speed").disabled = false;
                document.getElementById("cellLength").disabled = false;
                document.getElementById("cellMargin").disabled = false;
                document.getElementById("gameAreaWidth").disabled = false;
                document.getElementById("gameAreaHeight").disabled = false;
            }
        }
    }

    // 重新设置游戏区域
    function resetGameArea() {
        let cellLength = Number(document.getElementById("cellLength").value);
        let gameAreaWidth = Number(document.getElementById("gameAreaWidth").value);
        let gameAreaHeight = Number(document.getElementById("gameAreaHeight").value);
        let gameArea = document.getElementById("gameArea");
        // 输入校验
        if (gameAreaWidth < 3) {
            alert("宽度和高度必须大于等于3！");
            document.getElementById("gameAreaWidth").value = 3;
            gameAreaWidth = 3;
        } else if (gameAreaHeight < 3) {
            alert("宽度和高度必须大于等于3！");
            document.getElementById("gameAreaHeight").value = 3;
            gameAreaHeight = 3;
        }
        // 清空原有内容
        gameArea.innerHTML = "";
        // 填充格子
        let table = document.createElement("table");
        table.style.borderSpacing = document.getElementById("cellMargin").value + "px";
        for (let i = 0; i < gameAreaHeight + 2; i++) {
            let row = document.createElement("tr");
            for (let j = 0; j < gameAreaWidth + 2; j++) {
                let cell = document.createElement("td");
                cell.id = "cell-" + i + "-" + j;
                cell.style.width = cellLength + "px";
                cell.style.height = cellLength + "px";
                cell.style.padding = "0";
                // 背景设置为棋盘色
                if (i % 2 === 0 && j % 2 === 0 || i % 2 === 1 && j % 2 === 1) {
                    cell.style.backgroundColor = "#eee";
                } else {
                    cell.style.backgroundColor = "#ddd";
                }
                row.appendChild(cell);
            }
            table.appendChild(row);
        }
        gameArea.appendChild(table);
        // 绘制墙
        let wallNodes = new WallNodes();
        wallNodes.init();
        wallNodes.display();
    }

    resetGameArea(); // 载入页面后立即初始化游戏区域一次

    // 检查格子是否为空
    function checkCellEmpty(row, col) {
        return document.getElementById("cell-" + row + "-" + col).children.length === 0;
    }

    // 检查格子是否为食物
    function checkCellFood(row, col) {
        if (document.getElementById("cell-" + row + "-" + col).children.length === 0) {
            return false;
        } else {
            return document.getElementById("cell-" + row + "-" + col).firstElementChild.tagName === "DIV";
        }
    }

    // 适配高清屏
    function createHDCanvas(canvas, l, ratio) {
        canvas.width = l * ratio; // 实际渲染像素
        canvas.height = l * ratio; // 实际渲染像素
        canvas.style.width = `${l}px`; // 控制显示大小
        canvas.style.height = `${l}px`; // 控制显示大小
        return canvas;
    }

    // canvas绘制
    function drawCanvas(cell, type, rotation) {
        cell.innerHTML = "";  // 清除原有内容
        let ratio = window.devicePixelRatio || 1;
        let cellLength = Number(document.getElementById("cellLength").value);
        if (type === "Food") {  // 食物不需要绘制，直接使用 emoji
            let div = document.createElement("div");
            div.style.width = cellLength + "px";
            div.style.height = cellLength + "px";
            div.style.fontSize = cellLength * 0.8 + "px";
            div.style.lineHeight = cellLength + "px";
            div.style.backgroundColor = "rgba(0,0,0,0)";
            div.style.display = "flex";
            div.style.alignContent = "center";
            div.style.justifyContent = "center";
            div.style.margin = 0;
            div.style.padding = 0;
            let foods = ["🍎", "🍊", "🍋", "🍌", "🍉", "🍇", "🍓", "🍒", "🍑", "🍍", "🫐", "🍕", "🍔", "🌮", "🍰",
                "🥞", "🥐", "🍣", "🍤", "🥓", "🥩", "🍗", "🍖", "🧋", "🥤", "🐭"];
            div.innerHTML = foods[Math.floor(Math.random() * foods.length)];
            div.style.transform = `rotate(${rotation}deg)`;  // 旋转
            cell.appendChild(div);
            return;
        }
        let canvas = document.createElement("canvas");
        canvas.style.display = "block";
        canvas.style.padding = "0";
        canvas.style.margin = "0";
        canvas = createHDCanvas(canvas, cellLength, ratio);
        let ctx = canvas.getContext("2d");
        let pl = cellLength * ratio / 16;  // PixelLength 标准像素长度
        function PL(n) {
            return n * pl;
        }

        // 绘制墙面
        if (type === "Wall") {
            // 填充背景
            ctx.fillStyle = "#45283C";
            ctx.fillRect(PL(0), PL(0), PL(16), PL(16));
            // 绘制砖块
            ctx.fillStyle = "#8F563B";
            ctx.fillRect(PL(0), PL(1), PL(4), PL(3));
            ctx.fillRect(PL(5), PL(1), PL(7), PL(3));
            ctx.fillRect(PL(13), PL(1), PL(3), PL(3));
            ctx.fillRect(PL(1), PL(5), PL(7), PL(3));
            ctx.fillRect(PL(9), PL(5), PL(7), PL(3));
            ctx.fillRect(PL(0), PL(9), PL(4), PL(3));
            ctx.fillRect(PL(5), PL(9), PL(7), PL(3));
            ctx.fillRect(PL(13), PL(9), PL(3), PL(3));
            ctx.fillRect(PL(1), PL(13), PL(7), PL(3));
            ctx.fillRect(PL(9), PL(13), PL(7), PL(3));
        }
        // 绘制墙角
        if (type === "WallCorner") {
            // 填充背景
            ctx.fillStyle = "#45283C";
            ctx.fillRect(PL(0), PL(0), PL(16), PL(16));
            // 绘制砖块
            ctx.fillStyle = "#8F563B";
            ctx.fillRect(PL(0), PL(1), PL(4), PL(3));
            ctx.fillRect(PL(5), PL(1), PL(7), PL(3));
            ctx.fillRect(PL(13), PL(1), PL(2), PL(3));
            ctx.fillRect(PL(12), PL(5), PL(3), PL(7));
            ctx.fillRect(PL(12), PL(13), PL(3), PL(3));
            ctx.fillRect(PL(1), PL(5), PL(7), PL(3));
            ctx.fillRect(PL(9), PL(5), PL(2), PL(3));
            ctx.fillRect(PL(8), PL(9), PL(3), PL(7));
            ctx.fillRect(PL(0), PL(9), PL(4), PL(3));
            ctx.fillRect(PL(5), PL(9), PL(2), PL(3));
            ctx.fillRect(PL(4), PL(13), PL(3), PL(3));
            ctx.fillRect(PL(1), PL(13), PL(2), PL(3));
        }
        // 绘制蛇头
        if (type === "SnakeHead") {
            // 深色描边
            ctx.fillStyle = "#222034";
            ctx.fillRect(PL(5), PL(2), PL(6), PL(1));
            ctx.fillRect(PL(4), PL(3), PL(8), PL(1));
            ctx.fillRect(PL(3), PL(4), PL(10), PL(1));
            ctx.fillRect(PL(2), PL(5), PL(12), PL(11));
            ctx.fillRect(PL(1), PL(7), PL(14), PL(7));
            ctx.fillRect(PL(0), PL(9), PL(16), PL(4));
            // 红色部分
            ctx.fillStyle = "#D95763";
            ctx.fillRect(PL(7), PL(0), PL(2), PL(2));
            // 浅绿色部分
            ctx.fillStyle = "#99E550";
            ctx.fillRect(PL(5), PL(3), PL(6), PL(1));
            ctx.fillRect(PL(4), PL(4), PL(8), PL(1));
            ctx.fillRect(PL(3), PL(5), PL(10), PL(11));
            ctx.fillRect(PL(2), PL(7), PL(12), PL(7));
            ctx.fillRect(PL(1), PL(9), PL(14), PL(4));
            // 白色部分
            ctx.fillStyle = "#FFFFFF";
            ctx.fillRect(PL(4), PL(9), PL(2), PL(4));
            ctx.fillRect(PL(3), PL(10), PL(4), PL(2));
            ctx.fillRect(PL(10), PL(9), PL(2), PL(4));
            ctx.fillRect(PL(9), PL(10), PL(4), PL(2));
            // 深色细节
            ctx.fillStyle = "#222034";
            ctx.fillRect(PL(6), PL(5), PL(1), PL(1));
            ctx.fillRect(PL(9), PL(5), PL(1), PL(1));
            ctx.fillRect(PL(4), PL(10), PL(1), PL(1));
            ctx.fillRect(PL(10), PL(10), PL(1), PL(1));
        }
        // 绘制直蛇身
        if (type === "SnakeBodyStraight") {
            // 深色描边
            ctx.fillStyle = "#222034";
            ctx.fillRect(PL(2), PL(0), PL(12), PL(1));
            ctx.fillRect(PL(1), PL(1), PL(12), PL(2));
            ctx.fillRect(PL(0), PL(3), PL(12), PL(2));
            ctx.fillRect(PL(1), PL(5), PL(12), PL(2));
            ctx.fillRect(PL(2), PL(7), PL(12), PL(2));
            ctx.fillRect(PL(3), PL(9), PL(12), PL(2));
            ctx.fillRect(PL(4), PL(11), PL(12), PL(2));
            ctx.fillRect(PL(3), PL(13), PL(12), PL(2));
            ctx.fillRect(PL(2), PL(15), PL(12), PL(1));
            // 深绿色部分
            ctx.fillStyle = "#37946E";
            ctx.fillRect(PL(3), PL(0), PL(10), PL(1));
            ctx.fillRect(PL(2), PL(1), PL(10), PL(2));
            ctx.fillRect(PL(1), PL(3), PL(10), PL(2));
            ctx.fillRect(PL(2), PL(5), PL(10), PL(2));
            ctx.fillRect(PL(3), PL(7), PL(10), PL(1));
            // 浅绿色部分
            ctx.fillStyle = "#99E550";
            ctx.fillRect(PL(3), PL(8), PL(10), PL(1));
            ctx.fillRect(PL(4), PL(9), PL(10), PL(2));
            ctx.fillRect(PL(5), PL(11), PL(10), PL(2));
            ctx.fillRect(PL(4), PL(13), PL(10), PL(2));
            ctx.fillRect(PL(3), PL(15), PL(10), PL(1));
        }
        // 绘制弯蛇身
        if (type === "SnakeBodyBend") {
            // 深色描边
            ctx.fillStyle = "#222034";
            ctx.fillRect(PL(0), PL(2), PL(1), PL(1));
            ctx.fillRect(PL(1), PL(1), PL(3), PL(1));
            ctx.fillRect(PL(4), PL(0), PL(4), PL(1));
            ctx.fillRect(PL(8), PL(1), PL(3), PL(1));
            ctx.fillRect(PL(11), PL(2), PL(2), PL(1));
            ctx.fillRect(PL(13), PL(3), PL(1), PL(2));
            ctx.fillRect(PL(14), PL(5), PL(1), PL(3));
            ctx.fillRect(PL(15), PL(8), PL(1), PL(4));
            ctx.fillRect(PL(14), PL(12), PL(1), PL(3));
            ctx.fillRect(PL(13), PL(15), PL(1), PL(1));
            ctx.fillRect(PL(0), PL(13), PL(1), PL(1));
            ctx.fillRect(PL(1), PL(12), PL(2), PL(1));
            ctx.fillRect(PL(3), PL(13), PL(1), PL(2));
            ctx.fillRect(PL(2), PL(15), PL(1), PL(1));
            // 浅绿色部分
            ctx.fillStyle = "#99E550";
            ctx.fillRect(PL(0), PL(3), PL(13), PL(2));
            ctx.fillRect(PL(0), PL(5), PL(14), PL(3));
            ctx.fillRect(PL(0), PL(8), PL(15), PL(4));
            ctx.fillRect(PL(3), PL(12), PL(11), PL(1));
            ctx.fillRect(PL(4), PL(13), PL(10), PL(2));
            ctx.fillRect(PL(3), PL(15), PL(10), PL(1));
            // 深绿色部分
            ctx.fillStyle = "#37946E";
            ctx.fillRect(PL(4), PL(1), PL(4), PL(1));
            ctx.fillRect(PL(1), PL(2), PL(10), PL(1));
            ctx.fillRect(PL(0), PL(3), PL(13), PL(1));
            ctx.fillRect(PL(0), PL(4), PL(12), PL(1));
            ctx.fillRect(PL(0), PL(5), PL(11), PL(1));
            ctx.fillRect(PL(0), PL(6), PL(10), PL(1));
            ctx.fillRect(PL(0), PL(7), PL(9), PL(1));
            ctx.fillRect(PL(0), PL(8), PL(8), PL(1));
            ctx.fillRect(PL(0), PL(9), PL(7), PL(1));
            ctx.fillRect(PL(0), PL(10), PL(6), PL(1));
            ctx.fillRect(PL(0), PL(11), PL(5), PL(1));
            ctx.fillRect(PL(0), PL(12), PL(1), PL(1));
            ctx.fillRect(PL(3), PL(12), PL(1), PL(1));
        }
        // 绘制蛇尾
        if (type === "SnakeTail") {
            // 深色描边
            ctx.fillStyle = "#222034";
            ctx.fillRect(PL(2), PL(0), PL(1), PL(2));
            ctx.fillRect(PL(1), PL(2), PL(1), PL(4));
            ctx.fillRect(PL(2), PL(6), PL(1), PL(3));
            ctx.fillRect(PL(3), PL(9), PL(1), PL(2));
            ctx.fillRect(PL(4), PL(11), PL(1), PL(1));
            ctx.fillRect(PL(5), PL(12), PL(1), PL(1));
            ctx.fillRect(PL(6), PL(13), PL(1), PL(2));
            ctx.fillRect(PL(7), PL(15), PL(1), PL(1));
            ctx.fillRect(PL(8), PL(10), PL(1), PL(5));
            ctx.fillRect(PL(9), PL(6), PL(1), PL(4));
            ctx.fillRect(PL(10), PL(3), PL(1), PL(3));
            ctx.fillRect(PL(11), PL(2), PL(1), PL(1));
            ctx.fillRect(PL(12), PL(1), PL(1), PL(1));
            ctx.fillRect(PL(13), PL(0), PL(1), PL(1));
            // 深绿色部分
            ctx.fillStyle = "#37946E";
            ctx.fillRect(PL(3), PL(0), PL(10), PL(1));
            ctx.fillRect(PL(3), PL(1), PL(9), PL(1));
            ctx.fillRect(PL(2), PL(2), PL(9), PL(1));
            ctx.fillRect(PL(2), PL(3), PL(8), PL(3));
            ctx.fillRect(PL(3), PL(6), PL(6), PL(3));
            ctx.fillRect(PL(4), PL(9), PL(5), PL(1));
            ctx.fillRect(PL(4), PL(10), PL(4), PL(1));
            ctx.fillRect(PL(5), PL(11), PL(3), PL(1));
            ctx.fillRect(PL(6), PL(12), PL(2), PL(1));
            ctx.fillRect(PL(7), PL(13), PL(1), PL(2));
        }
        canvas.style.transform = `rotate(${rotation}deg)`;  // 旋转
        cell.appendChild(canvas);
    }

    // 全局变量存储游戏开始结束状态
    let gameStart = false;

    // 开始游戏
    function startGame() {
        gameStart = true;
        resetGameArea();
        // 得分清零
        document.getElementById("score").innerText = 0;
        // 禁止修改游戏区域设置
        document.getElementById("speed").disabled = true;
        document.getElementById("cellLength").disabled = true;
        document.getElementById("cellMargin").disabled = true;
        document.getElementById("gameAreaWidth").disabled = true;
        document.getElementById("gameAreaHeight").disabled = true;
        // 创建蛇
        let snake = new SnakeList();
        snake.init();
        snake.display();
        // 创建食物
        let food = new FoodNode();
        food.init();
        food.display();
        // 临时变量存储目标方向
        let targetDirection = "down";
        // 键盘事件监听，可以使用上下左右和wasd键控制
        document.onkeydown = function (event) {
            let e = event || window.event || arguments.callee.caller.arguments[0];
            if (e && e.keyCode === 37 || e && e.keyCode === 65) { // 按左键或a键
                targetDirection = "left";
            }
            if (e && e.keyCode === 38 || e && e.keyCode === 87) { // 按上键或w键
                targetDirection = "up";
            }
            if (e && e.keyCode === 39 || e && e.keyCode === 68) { // 按右键或d键
                targetDirection = "right";
            }
            if (e && e.keyCode === 40 || e && e.keyCode === 83) { // 按下键或s键
                targetDirection = "down";
            }
        };
        // 每过设定时间移动一次
        let speed = Number(document.getElementById("speed").value);
        let timer = setInterval(function () {
            snake.move(targetDirection);
            // 游戏结束时暂停定时器
            if (!gameStart) {
                clearInterval(timer);
            }
        }, speed);
    }
</script>
</html>

```
